---------------------------------------------------------------------------
-- Dummy BLOCKS top-level interface
-- To be autogenerated !
---------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

library unisim;
use unisim.vcomponents.all;

--library work;

--use work.addr_defines.all; -- This autogenerated file will no longer be needed!
use work.top_defines.all;

entity soft_blocks is
generic (
    SIM                 : string  := "FALSE"
);
port (
        -- Global clock and reset from panda_ps
        FCLK_CLK0                       : in  std_logic;
        FCLK_RESET0                     : in  std_logic;
        -- Configuration and Status Interface Block
    read_strobe                 : in  std_logic_vector(MOD_COUNT-1 downto 0);
    read_address        : in  std_logic_vector(PAGE_AW-1 downto 0);
        read_data                       : out std32_array(MOD_COUNT-1 downto 0);
    read_ack            : out std_logic_vector(MOD_COUNT-1 downto 0) := (others => '1');
    write_strobe        : in  std_logic_vector(MOD_COUNT-1 downto 0);
    write_address       : in  std_logic_vector(PAGE_AW-1 downto 0);
    write_data                  : in  std_logic_vector(31 downto 0);
    write_ack                   : out std_logic_vector(MOD_COUNT-1 downto 0) := (others => '1');
    -- Bus Outputs
        bit_bus             : inout bit_bus_t;
        pos_bus             : inout pos_bus_t;
    -- PCOMP & PGEN Block
        rdma_req            : out std_logic_vector(5 downto 0);
        rdma_ack            : in  std_logic_vector(5 downto 0);
        rdma_done           : in  std_logic;
        rdma_addr           : out std32_array(5 downto 0);
        rdma_len            : out std8_array(5 downto 0);
        rdma_data           : in  std_logic_vector(31 downto 0);
        rdma_valid          : in  std_logic_vector(5 downto 0);
    --
    FMC                 : inout FMC_interface;
    SFP1                : inout SFP_interface;
    SFP2                : inout SFP_interface;
    SFP3                : inout SFP_interface
);
end soft_blocks;

architecture rtl of soft_blocks is

-- Definitions below need to be automatically populated by Jinja
-- Only for soft blocks though!
-- "NUM" paramters resolved here and inherited in blocks by generics

-- Functional Address Space Chip Selects

constant LUT_CS : natural := 9;
constant SRGATE_CS : natural := 10;
constant DIV_CS : natural := 11;
constant PULSE_CS : natural := 12;
constant SEQ_CS : natural := 13;
constant QDEC_CS : natural := 14;
constant POSENC_CS : natural := 15;
constant CALC_CS : natural := 16;
constant COUNTER_CS : natural := 17;
constant PGEN_CS : natural := 18;
constant PCOMP_CS : natural := 19;
constant BITS_CS : natural := 21;
constant CLOCKS_CS : natural := 22;
constant FILTER_CS : natural := 24;
constant SFP_CS : natural := 25;
constant FMC_CS : natural := 26;

-- Block instantiation

constant LUT_NUM : natural := 8;
constant SRGATE_NUM : natural := 4;
constant DIV_NUM : natural := 4;
constant PULSE_NUM : natural := 4;
constant SEQ_NUM : natural := 4;
constant QDEC_NUM : natural := 4;
constant POSENC_NUM : natural := 4;
constant CALC_NUM : natural := 2;
constant COUNTER_NUM : natural := 8;
constant PGEN_NUM : natural := 2;
constant PCOMP_NUM : natural := 4;
constant BITS_NUM : natural := 1;
constant CLOCKS_NUM : natural := 1; -- not needed, but keep?
constant FILTER_NUM : natural := 1; -- not needed, but keep?
constant SFP_NUM : natural := 1; -- not needed, but keep?
constant FMC_NUM : natural := 1; -- not needed, but keep?

begin

---------------------------------------------------------------------------
-- 5-Input LUT
---------------------------------------------------------------------------
lut_inst : entity work.lut_top
generic map ( NUM => LUT_NUM)
port map (
    clk_i               => FCLK_CLK0,
    reset_i             => FCLK_RESET0,

    read_strobe_i       => read_strobe(LUT_CS),
    read_address_i      => read_address,
    read_data_o         => read_data(LUT_CS),
    read_ack_o          => read_ack(LUT_CS),

    write_strobe_i      => write_strobe(LUT_CS),
    write_address_i     => write_address,
    write_data_i        => write_data,
    write_ack_o         => write_ack(LUT_CS),

    bit_bus_i            => bit_bus,
    out_o               => bit_bus(39 downto 32)   --AUTOGEN
);

---------------------------------------------------------------------------
-- SRGATE
---------------------------------------------------------------------------
srgate_inst : entity work.srgate_top
generic map ( NUM => SRGATE_NUM)
port map (
    clk_i               => FCLK_CLK0,
    reset_i             => FCLK_RESET0,

    read_strobe_i       => read_strobe(SRGATE_CS),
    read_address_i      => read_address,
    read_data_o         => read_data(SRGATE_CS),
    read_ack_o          => read_ack(SRGATE_CS),

    write_strobe_i      => write_strobe(SRGATE_CS),
    write_address_i     => write_address,
    write_data_i        => write_data,
    write_ack_o         => write_ack(SRGATE_CS),

    bit_bus_i            => bit_bus,
    out_o               => bit_bus(43 downto 40)   --AUTOGEN
);


---------------------------------------------------------------------------
-- FILTER
---------------------------------------------------------------------------
inst_filter_top : entity work.filter_top
generic map ( NUM => FILTER_NUM)
port map(
    clk_i               => FCLK_CLK0,
    reset_i             => FCLK_RESET0,

    read_strobe_i       => read_strobe(FILTER_CS),
    read_address_i      => read_address,
    read_data_o         => read_data(FILTER_CS),
    read_ack_o          => read_ack(FILTER_CS),

    write_strobe_i      => write_strobe(FILTER_CS),
    write_address_i     => write_address,
    write_data_i        => write_data,
    write_ack_o         => write_ack(FILTER_CS),
    bit_bus_i            => bit_bus,
    pos_bus_i            => pos_bus,
    out_o               => pos_bus(20 downto 20),   --AUTOGEN
    ready_o             => bit_bus(117 downto 117)    --AUTOGEN
 );


---------------------------------------------------------------------------
-- DIVIDER
---------------------------------------------------------------------------
div_inst : entity work.div_top
generic map ( NUM => DIV_NUM)
port map (
    clk_i               => FCLK_CLK0,
    reset_i             => FCLK_RESET0,

    read_strobe_i       => read_strobe(DIV_CS),
    read_address_i      => read_address,
    read_data_o         => read_data(DIV_CS),
    read_ack_o          => read_ack(DIV_CS),

    write_strobe_i      => write_strobe(DIV_CS),
    write_address_i     => write_address,
    write_data_i        => write_data,
    write_ack_o         => write_ack(DIV_CS),

    bit_bus_i            => bit_bus,
    outd_o              => bit_bus(47 downto 44),  --AUTOGEN
    outn_o              => bit_bus(51 downto 48)    --AUTOGEN
);

---------------------------------------------------------------------------
-- PULSE GENERATOR
---------------------------------------------------------------------------
pulse_inst : entity work.pulse_top
generic map ( NUM => PULSE_NUM)
port map (
    clk_i               => FCLK_CLK0,
    reset_i             => FCLK_RESET0,

    read_strobe_i       => read_strobe(PULSE_CS),
    read_address_i      => read_address,
    read_data_o         => read_data(PULSE_CS),
    read_ack_o          => read_ack(PULSE_CS),

    write_strobe_i      => write_strobe(PULSE_CS),
    write_address_i     => write_address,
    write_data_i        => write_data,
    write_ack_o         => write_ack(PULSE_CS),

    bit_bus_i            => bit_bus,
    out_o               => bit_bus(55 downto 52)  --AUTOGEN
);

---------------------------------------------------------------------------
-- SEQEUENCER
---------------------------------------------------------------------------
seq_inst : entity work.sequencer_top
generic map ( NUM => SEQ_NUM)
port map (
    clk_i               => FCLK_CLK0,
    reset_i             => FCLK_RESET0,

    read_strobe_i       => read_strobe(SEQ_CS),
    read_address_i      => read_address,
    read_data_o         => read_data(SEQ_CS),
    read_ack_o          => read_ack(SEQ_CS),

    write_strobe_i      => write_strobe(SEQ_CS),
    write_address_i     => write_address,
    write_data_i        => write_data,
    write_ack_o         => write_ack(SEQ_CS),

    bit_bus_i            => bit_bus,

    outa_o              => bit_bus(59 downto 56),  --AUTOGEN
    outb_o              => bit_bus(63 downto 60),  --AUTOGEN
    outc_o              => bit_bus(67 downto 64),  --AUTOGEN
    outd_o              => bit_bus(71 downto 68),  --AUTOGEN
    oute_o              => bit_bus(75 downto 72),  --AUTOGEN
    outf_o              => bit_bus(79 downto 76),  --AUTOGEN
    active_o            => bit_bus(83 downto 80)  --AUTOGEN
);

---------------------------------------------------------------------------
-- QDEC
---------------------------------------------------------------------------
qdec_inst : entity work.qdec_top
generic map ( NUM => QDEC_NUM)
port map (
    clk_i               => FCLK_CLK0,
    reset_i             => FCLK_RESET0,

    read_strobe_i       => read_strobe(QDEC_CS),
    read_address_i      => read_address,
    read_data_o         => read_data(QDEC_CS),
    read_ack_o          => read_ack(QDEC_CS),

    write_strobe_i      => write_strobe(QDEC_CS),
    write_address_i     => write_address,
    write_data_i        => write_data,
    write_ack_o         => write_ack(QDEC_CS),

    bit_bus_i            => bit_bus,
    out_o               => pos_bus(7 downto 4)  --AUTOGEN
);

---------------------------------------------------------------------------
-- POSENC (Encoder Inputs)
---------------------------------------------------------------------------
posenc_inst : entity work.posenc_top
generic map ( NUM => POSENC_NUM)
port map (
    clk_i               => FCLK_CLK0,
    reset_i             => FCLK_RESET0,

    read_strobe_i       => read_strobe(POSENC_CS),
    read_address_i      => read_address,
    read_data_o         => read_data(POSENC_CS),
    read_ack_o          => read_ack(POSENC_CS),

    write_strobe_i      => write_strobe(POSENC_CS),
    write_address_i     => write_address,
    write_data_i        => write_data,
    write_ack_o         => write_ack(POSENC_CS),

    a_o                 => bit_bus(87 downto 84),  --AUTOGEN
    b_o                 => bit_bus(91 downto 88),  --AUTOGEN
    bit_bus_i            => bit_bus,
    pos_bus_i            => pos_bus
);

---------------------------------------------------------------------------
-- COUNTER/TIMER
---------------------------------------------------------------------------
counter_inst : entity work.counter_top
generic map ( NUM => COUNTER_NUM)
port map (
    clk_i               => FCLK_CLK0,
    reset_i             => FCLK_RESET0,

    read_strobe_i       => read_strobe(COUNTER_CS),
    read_address_i      => read_address,
    read_data_o         => read_data(COUNTER_CS),
    read_ack_o          => read_ack(COUNTER_CS),

    write_strobe_i      => write_strobe(COUNTER_CS),
    write_address_i     => write_address,
    write_data_i        => write_data,
    write_ack_o         => write_ack(COUNTER_CS),

    bit_bus_i            => bit_bus,
    carry_o             => bit_bus(99 downto 92),  --AUTOGEN
    out_o               => pos_bus(17 downto 10)  --AUTOGEN
);

---------------------------------------------------------------------------
-- CALC
---------------------------------------------------------------------------
calc_inst : entity work.calc_top
generic map ( NUM => CALC_NUM)
port map (
    clk_i               => FCLK_CLK0,
    reset_i             => FCLK_RESET0,

    read_strobe_i       => read_strobe(CALC_CS),
    read_address_i      => read_address,
    read_data_o         => read_data(CALC_CS),
    read_ack_o          => read_ack(CALC_CS),

    write_strobe_i      => write_strobe(CALC_CS),
    write_address_i     => write_address,
    write_data_i        => write_data,
    write_ack_o         => write_ack(CALC_CS),

    pos_bus_i            => pos_bus,
    out_o               => pos_bus(9 downto 8)  --AUTOGEN
);

---------------------------------------------------------------------------
-- POSITION COMPARE
---------------------------------------------------------------------------
pcomp_inst : entity work.pcomp_top
generic map ( NUM => PCOMP_NUM)
port map (
    clk_i               => FCLK_CLK0,
    reset_i             => FCLK_RESET0,

    read_strobe_i       => read_strobe(PCOMP_CS),
    read_address_i      => read_address,
    read_data_o         => read_data(PCOMP_CS),
    read_ack_o          => read_ack(PCOMP_CS),

    write_strobe_i      => write_strobe(PCOMP_CS),
    write_address_i     => write_address,
    write_data_i        => write_data,
    write_ack_o         => write_ack(PCOMP_CS),

    dma_req_o           => rdma_req(5 downto 2),
    dma_ack_i           => rdma_ack(5 downto 2),
    dma_done_i          => rdma_done,
    dma_addr_o          => rdma_addr(5 downto 2),
    dma_len_o           => rdma_len(5 downto 2),
    dma_data_i          => rdma_data,
    dma_valid_i         => rdma_valid(5 downto 2),
    bit_bus_i            => bit_bus,
    pos_bus_i            => pos_bus,
    act_o               => bit_bus(103 downto 100),  --AUTOGEN
    out_o               => bit_bus(107 downto 104)  --AUTOGEN
);

---------------------------------------------------------------------------
-- POSITION GENERATION
---------------------------------------------------------------------------
pgen_inst : entity work.pgen_top
generic map ( NUM => PGEN_NUM)
port map (
    clk_i               => FCLK_CLK0,
    reset_i             => FCLK_RESET0,

    read_strobe_i       => read_strobe(PGEN_CS),
    read_address_i      => read_address,
    read_data_o         => read_data(PGEN_CS),
    read_ack_o          => read_ack(PGEN_CS),

    write_strobe_i      => write_strobe(PGEN_CS),
    write_address_i     => write_address,
    write_data_i        => write_data,
    write_ack_o         => write_ack(PGEN_CS),

    dma_req_o           => rdma_req(1 downto 0),
    dma_ack_i           => rdma_ack(1 downto 0),
    dma_done_i          => rdma_done,
    dma_addr_o          => rdma_addr(1 downto 0),
    dma_len_o           => rdma_len(1 downto 0),
    dma_data_i          => rdma_data,
    dma_valid_i         => rdma_valid(1 downto 0),
    bit_bus_i            => bit_bus,
    out_o               => pos_bus(19 downto 18)  --AUTOGEN
);

---------------------------------------------------------------------------
-- CLOCKS
---------------------------------------------------------------------------
clocks_inst : entity work.clocks_top
generic map ( NUM => CLOCKS_NUM)
port map (
    clk_i               => FCLK_CLK0,
    reset_i             => FCLK_RESET0,

    read_strobe_i       => read_strobe(CLOCKS_CS),
    read_address_i      => read_address,
    read_data_o         => read_data(CLOCKS_CS),
    read_ack_o          => read_ack(CLOCKS_CS),

    write_strobe_i      => write_strobe(CLOCKS_CS),
    write_address_i     => write_address,
    write_data_i        => write_data,
    write_ack_o         => write_ack(CLOCKS_CS),

    clocks_a_o          => bit_bus(113),  --AUTOGEN
    clocks_b_o          => bit_bus(114),  --AUTOGEN
    clocks_c_o          => bit_bus(115),  --AUTOGEN
    clocks_d_o          => bit_bus(116)  --AUTOGEN
);

---------------------------------------------------------------------------
-- BITS
---------------------------------------------------------------------------
bits_inst : entity work.bits_top
generic map ( NUM => BITS_NUM)
port map (
    clk_i               => FCLK_CLK0,
    reset_i             => FCLK_RESET0,

    read_strobe_i       => read_strobe(BITS_CS),
    read_address_i      => read_address,
    read_data_o         => read_data(BITS_CS),
    read_ack_o          => read_ack(BITS_CS),

    write_strobe_i      => write_strobe(BITS_CS),
    write_address_i     => write_address,
    write_data_i        => write_data,
    write_ack_o         => write_ack(BITS_CS),


    bits_a_o            => bit_bus(109),  --AUTOGEN
    bits_b_o            => bit_bus(110),  --AUTOGEN
    bits_c_o            => bit_bus(111),  --AUTOGEN
    bits_d_o            => bit_bus(112)  --AUTOGEN
);

---------------------------------------------------------------------------
-- FMC Loopback design
---------------------------------------------------------------------------
FMC_GEN : IF (SIM = "FALSE") GENERATE
    fmc_inst : entity work.fmc_top
    port map (
        clk_i               => FCLK_CLK0,
        reset_i             => FCLK_RESET0,

        bit_bus_i            => bit_bus,
        pos_bus_i            => pos_bus,
        fmc_inputs_o        => open,
        fmc_data_o          => open,

        read_strobe_i       => read_strobe(FMC_CS),
        read_address_i      => read_address,
        read_data_o         => read_data(FMC_CS),
        read_ack_o          => read_ack(FMC_CS),

        write_strobe_i      => write_strobe(FMC_CS),
        write_address_i     => write_address,
        write_data_i        => write_data,
        write_ack_o         => write_ack(FMC_CS),

        FMC_interface         => FMC
    );
END GENERATE;

---------------------------------------------------------------------------
-- SFP Loopback design
---------------------------------------------------------------------------
SFP_GEN : IF (SIM = "FALSE") GENERATE

    sfp1_inst : entity work.sfp_loopback_top
    port map (
        clk_i               => FCLK_CLK0,
        reset_i             => FCLK_RESET0,

        bit_bus_i            => bit_bus,
        sfp_inputs_o        => open,
        sfp_data_o          => open,

        read_strobe_i       => read_strobe(SFP1_CS),
        read_address_i      => read_address,
        read_data_o         => read_data(SFP1_CS),
        read_ack_o          => read_ack(SFP1_CS),

        write_strobe_i      => write_strobe(SFP1_CS),
        write_address_i     => write_address,
        write_data_i        => write_data,
        write_ack_o         => write_ack(SFP1_CS),

        SFP_interface       => SFP1
    );

    sfp2_inst : entity work.sfp_top
    port map (
        clk_i               => FCLK_CLK0,
        reset_i             => FCLK_RESET0,

        bit_bus_i            => bit_bus,
        sfp_inputs_o        => open,
        sfp_data_o          => open,

        read_strobe_i       => read_strobe(SFP2_CS),
        read_address_i      => read_address,
        read_data_o         => read_data(SFP2_CS),
        read_ack_o          => read_ack(SFP2_CS),

        write_strobe_i      => write_strobe(SFP2_CS),
        write_address_i     => write_address,
        write_data_i        => write_data,
        write_ack_o         => write_ack(SFP2_CS),

        SFP_interface        => SFP2
    );

    sfp3_inst : entity work.sfp_top
    port map (
        clk_i               => FCLK_CLK0,
        reset_i             => FCLK_RESET0,

        bit_bus_i            => bit_bus,
        sfp_inputs_o        => open,
        sfp_data_o          => open,

        read_strobe_i       => read_strobe(SFP3_CS),
        read_address_i      => read_address,
        read_data_o         => read_data(SFP3_CS),
        read_ack_o          => read_ack(SFP3_CS),

        write_strobe_i      => write_strobe(SFP3_CS),
        write_address_i     => write_address,
        write_data_i        => write_data,
        write_ack_o         => write_ack(SFP3_CS),

        SFP_interface       => SFP3
    );
END GENERATE;

end rtl;

